schema {
  query: StandaloneQuery
  mutation: StandaloneMutation
  subscription: StandaloneSubscription
}

type Action {
  raw(encode: String = "hex"): String!
  inspection: String!
}

type ActionMutation {
  createAvatar(avatarName: String!, avatarIndex: Int!, hairIndex: Int!, lensIndex: Int!, earIndex: Int!, tailIndex: Int!): TxId!
  hackAndSlash(avatarAddress: Address!, worldId: Int!, stageId: Int!, weeklyArenaAddress: Address!, rankingArenaAddress: Address!, costumeIds: [Guid], equipmentIds: [Guid], consumableIds: [Guid]): TxId!
  combinationEquipment(avatarAddress: Address!, recipeId: Int!, slotIndex: Int!, subRecipeId: Int): TxId!
  itemEnhancement(avatarAddress: Address!, itemId: Guid!, materialId: Guid!, slotIndex: Int!): TxId!
  buy(sellerAgentAddress: Address!, sellerAvatarAddress: Address!, buyerAvatarAddress: Address!, productId: Guid!): TxId!
  sell(sellerAvatarAddress: Address!, itemId: Guid!, price: Int!): TxId!
  dailyReward(avatarAddress: Address!): TxId!
  combinationConsumable(avatarAddress: Address!, recipeId: Int!, slotIndex: Int!): TxId!
}

type ActivationStatusMutation {
  activateAccount(encodedActivationKey: String!): Boolean!
}

type ActivationStatusQuery {
  activated: Boolean!
}

scalar Address

type AgentStateType {
  address: Address!
  avatarAddresses: [Address!]
  gold: String!
}

type AppProtocolVersionType {
  version: Int!
  signer: Address!
  signature: ByteString!
  extra: ByteString
}

type ArenaInfoType {
  avatarAddress: Address!
  agentAddress: Address!
  avatarName: String!
  arenaRecord: ArenaRecordType!
  level: Int!
  combatPoint: Int!
  armorId: Int!
  active: Boolean!
  dailyChallengeCount: Int!
  score: Int!
}

type ArenaRecordType {
  win: Int
  lose: Int
  draw: Int
}

type AuthenticationMutation {
  login(privateKey: ByteString!): Boolean!
  logout: Boolean!
}

type AvatarStateType {
  address: Address!
  blockIndex: Int!
  characterId: Int!
  dailyRewardReceivedIndex: Long!
  agentAddress: Address!
  rankingMapAddress: Address!
  updatedAt: Long!
  name: String!
  exp: Int!
  level: Int!
  actionPoint: Int!
  ear: Int!
  hair: Int!
  lens: Int!
  tail: Int!
  inventory: InventoryType!
  combinationSlotAddresses: [Address!]!
  itemMap: CollectionMapType!
  eventMap: CollectionMapType!
  monsterMap: CollectionMapType!
  stageMap: CollectionMapType!
  questList: QuestListType!
  mailBox: MailBoxType!
  worldInformation: WorldInformationType!
}

scalar BigInt

type Block {
  hash: ID!
  index: Long!
  difficulty: Long!
  totalDifficulty: BigInt!
  nonce: ByteString!
  miner: Address!
  previousBlock: Block
  timestamp: DateTimeOffset!
  stateRootHash: ByteString
  transactions: [Transaction!]!
}

type BlockHeader {
  index: Int!
  id: ID!
  hash: String!
  miner: Address
}

type BlockQuery {
  blocks(desc: Boolean = false, offset: Int = 0, limit: Int, excludeEmptyTxs: Boolean = false, miner: Address): [Block!]!
  block(hash: ID, index: ID): Block
}

scalar ByteString

type CollectionMapType {
  count: Int!
  pairs: [[Int]!]!
}

type ConsumableType {
  grade: Int!
  id: Int!
  itemType: ItemType!
  itemSubType: ItemSubType!
  elementalType: ElementalType!
  itemId: Guid!
  mainStat: StatType!
}

type CostumeType {
  grade: Int!
  id: Int!
  itemType: ItemType!
  itemSubType: ItemSubType!
  elementalType: ElementalType!
  itemId: Guid!
  equipped: Boolean!
}

scalar DateTimeOffset

scalar Decimal

type DecimalStatType {
  type: StatType!
  value: Decimal!
}

type DifferentAppProtocolVersionEncounterType {
  peer: String!
  peerVersion: AppProtocolVersionType!
  localVersion: AppProtocolVersionType!
}

enum ElementalType {
  NORMAL
  FIRE
  WATER
  LAND
  WIND
}

type EquipmentType {
  grade: Int!
  id: Int!
  itemType: ItemType!
  itemSubType: ItemSubType!
  elementalType: ElementalType!
  setId: Int!
  stat: DecimalStatType!
  equipped: Boolean!
  itemId: Guid!
}

scalar Guid

type InventoryType {
  consumables: [ConsumableType!]!
  materials: [MaterialType!]!
  equipments: [EquipmentType!]!
  costumes: [CostumeType!]!
}

enum ItemSubType {
  FOOD
  FULL_COSTUME
  HAIR_COSTUME
  EAR_COSTUME
  EYE_COSTUME
  TAIL_COSTUME
  WEAPON
  ARMOR
  BELT
  NECKLACE
  RING
  EQUIPMENT_MATERIAL
  FOOD_MATERIAL
  MONSTER_PART
  NORMAL_MATERIAL
  HOURGLASS
  AP_STONE
  CHEST
  TITLE
}

enum ItemType {
  CONSUMABLE
  COSTUME
  EQUIPMENT
  MATERIAL
}

type ItemUsableType {
  grade: Int!
  id: Int!
  itemType: ItemType!
  itemSubType: ItemSubType!
  elementalType: ElementalType!
  itemId: Guid!
}

scalar Long

type MailBoxType {
  count: Int!
  mails: [MailType!]!
}

type MailType {
  id: Guid!
  requiredBlockIndex: Long!
  blockIndex: Long!
}

type MaterialType {
  grade: Int!
  id: Int!
  itemType: ItemType!
  itemSubType: ItemSubType!
  elementalType: ElementalType!
  itemId: ByteString!
}

type NodeExceptionType {
  code: Int!
  message: String!
}

type NodeState {
  preloaded: Boolean!
}

type NodeStatusType {
  bootstrapEnded: Boolean!
  preloadEnded: Boolean!
  tip: BlockHeader!
  topmostBlocks(limit: Int!, miner: Address): [BlockHeader]!
  stagedTxIds(address: Address): [TxId]
  genesis: BlockHeader!
  isMining: Boolean!
}

enum NotificationEnum {
  REFILL
  HAS
  COMBINATION_EQUIPMENT
  COMBINATION_CONSUMABLE
  BUYER
  SELLER
}

type NotificationType {
  type: NotificationEnum!
  message: String
  receiver: Address!
}

type PeerChainStateQuery {
  state: [String]!
}

type PreloadStateExtraType {
  type: String!
  currentCount: Long!
  totalCount: Long!
}

type PreloadStateType {
  currentPhase: Long!
  totalPhase: Long!
  extra: PreloadStateExtraType!
}

type Query {
  blockQuery: BlockQuery
  transactionQuery: TransactionQuery
  nodeState: NodeState!
}

type QuestListType {
  completedQuestIds: [Int!]!
}

type RankingInfoType {
  exp: Long!
  level: Int!
  armorId: Int!
  updatedAt: Long!
  stageClearedBlockIndex: Long!
  agentAddress: Address!
  avatarAddress: Address!
  avatarName: String!
}

type RankingMapStateType {
  address: Address!
  capacity: Int!
  rankingInfos: [RankingInfoType!]!
}

type ShopItemType {
  sellerAgentAddress: Address!
  sellerAvatarAddress: Address!
  productId: Guid!
  price: String!
  itemUsable: ItemUsableType
  costume: CostumeType
}

type ShopStateType {
  address: Address!
  products(id: Int, itemSubType: ItemSubType, maximumPrice: Int): [ShopItemType]!
}

type StandaloneMutation {
  auth: AuthenticationMutation
  activationStatus: ActivationStatusMutation
  action: ActionMutation
  stageTx(payload: String!): Boolean!
  transferGold(recipient: Address!, amount: String!): TxId
}

type StandaloneQuery {
  stateQuery(hash: ByteString): StateQuery!
  nodeStatus: NodeStatusType!
  chainQuery: Query!
  activationStatus: ActivationStatusQuery!
  peerChainState: PeerChainStateQuery!
  goldBalance(address: Address!, hash: ByteString): String!
  nextTxNonce(address: Address!): Long!
}

type StandaloneSubscription {
  tipChanged: TipChanged
  preloadProgress: PreloadStateType
  nodeStatus: NodeStatusType
  differentAppProtocolVersionEncounter: DifferentAppProtocolVersionEncounterType!
  notification: NotificationType!
  nodeException: NodeExceptionType!
}

enum StatType {
  NONE
  HP
  ATK
  DEF
  CRI
  HIT
  SPD
}

type StateQuery {
  avatar(address: Address): AvatarStateType
  rankingMap(index: Int!): RankingMapStateType
  shop: ShopStateType
  weeklyArena(index: Int!): WeeklyArenaStateType
  agent(address: Address!): AgentStateType
  raw(address: Address!): ByteString
}

type TipChanged {
  index: Long!
  hash: ByteString
}

type Transaction {
  id: ID!
  nonce: Long!
  signer: Address!
  publicKey: ByteString!
  updatedAddresses: [Address!]!
  signature: ByteString!
  timestamp: DateTimeOffset!
  actions: [Action!]!
  blockRef: [Block!]
}

type TransactionQuery {
  transactions(signer: Address, involvedAddress: Address, desc: Boolean = false, offset: Int = 0, limit: Int): [Transaction!]!
  stagedTransactions(signer: Address, involvedAddress: Address, desc: Boolean = false, offset: Int = 0, limit: Int): [Transaction!]!
  transaction(id: ID): Transaction
}

scalar TxId

type WeeklyArenaStateType {
  address: Address!
  ended: Boolean!
  orderedArenaInfos: [ArenaInfoType]!
}

type WorldInformationType {
  isStageCleared(stageId: Int!): Boolean!
  isWorldUnlocked(worldId: Int!): Boolean!
  world(worldId: Int!): WorldType!
}

type WorldType {
  id: Int!
  name: String!
  isUnlocked: Boolean!
  isStageCleared: Boolean!
  unlockedBlockIndex: Long!
  stageClearedBlockIndex: Long!
  stageBegin: Int!
  stageEnd: Int!
  stageClearedId: Int!
}
